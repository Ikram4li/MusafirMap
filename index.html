<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Home & Destination Boundaries + Buffer & Overlap</title>

<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<style>
  html, body { height: 100%; margin: 0; }
  #map { height: 100%; width: 100%; }

  #searchBar {
    position: absolute;
    top: 10px; left: 50%; transform: translateX(-50%);
    z-index: 1000; background: white; padding: 10px;
    border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.25);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    display: grid; grid-template-columns: auto 1.7fr 1.7fr 0.75fr 1.4fr; gap: 7px;
    width: min(900px, 94vw);
  }
  .field { position: relative; }
  input[type="text"], input[type="number"], select, button {
    width: 100%; padding: 8px 10px; font-size: 14px; box-sizing: border-box;
    border: 1px solid #ccc; border-radius: 6px;
  }
  #suggestHome, #suggestDest {
    position: absolute; left: 0; right: 0; top: calc(100% + 2px);
    background: white; border: 1px solid #ccc; border-radius: 6px;
    max-height: 220px; overflow-y: auto; display: none; z-index: 1100;
  }
  .suggestion { padding: 8px 10px; cursor: pointer; }
  .suggestion:hover { background: #f2f2f2; }

  #legend {
    position: absolute; bottom: 20px; right: 8px; z-index: 1000;
    background: white; padding: 5px 5px; border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.25); font-size: 13px; line-height: 1.4;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    width: 150px;
  }
  #legend h4 { margin: 0 0 8px; font-size: 14px; text-align: center; }
  .legend-item { display: flex; align-items: center; gap: 8px; margin: 6px 0; }
  .color-box { width: 18px; height: 18px; border-radius: 4px; border: 1px solid #0002; }
  .home-boundary { background: #000; }
  .home-buffer { background: #1e90ff; } /* blue */
  .dest-outside { background: #2ecc71; } /* green */
  .dest-inside { background: #e74c3c; }  /* red */
  .point-note { font-size: 10px; color: #555; margin-top: 8px; }

  /* === Hamburger Menu === */
  #menuWrap { position: relative; display: flex; align-items: center; justify-content: center; }
  .hamburger-btn {
    width: 36px; height: 36px;
    border-radius: 8px; border: 1px solid #ccc;
    background: #fff; cursor: pointer; display: inline-flex; align-items: center; justify-content: center;
  }
  .hamburger-btn:focus { outline: 2px solid #1e90ff; outline-offset: 2px; }
  .hamburger-icon { width: 18px; height: 14px; position: relative; }
  .hamburger-icon span { position: absolute; left: 0; right: 0; height: 2px; background: #333; border-radius: 2px; }
  .hamburger-icon span:nth-child(1) { top: 0; }
  .hamburger-icon span:nth-child(2) { top: 6px; }
  .hamburger-icon span:nth-child(3) { top: 12px; }

  #menuDropdown {
    position: absolute; top: calc(100% + 6px); left: 0;
    min-width: 220px; background: #fff; border: 1px solid #ccc; border-radius: 10px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.18); padding: 8px; z-index: 1200; display: none;
  }
  #menuDropdown.open { display: block; }
  .menu-item { display: flex; gap: 8px; align-items: center; padding: 8px 10px; border-radius: 8px; text-decoration: none; color: #222; font-size: 14px; }
  .menu-item:hover { background: #f5f7fb; }
  .menu-divider { height: 1px; background: #e5e7eb; margin: 6px 0; }
  @media (max-width: 560px) { #menuDropdown { min-width: 180px; } }
</style>
</head>
<body>

<div id="searchBar">
  <div id="menuWrap">
    <button class="hamburger-btn" id="menuBtn" aria-expanded="false" aria-controls="menuDropdown" aria-label="Open menu">
      <div class="hamburger-icon" aria-hidden="true">
        <span></span><span></span><span></span>
      </div>
    </button>
    <div id="menuDropdown" role="menu" aria-labelledby="menuBtn">
  <a class="menu-item" href="https://www.musafirmap.com/about">üìñ Instructions</a>
  <a class="menu-item" href="https://www.musafirmap.com">üó∫Ô∏è Map</a>
  <a class="menu-item" href="https://www.musafirmap.com/about">‚ùì Help</a>
</div>

  </div>
  <div class="field">
    <input type="text" id="homeInput" placeholder="Home City / Address / Postcode" autocomplete="off" spellcheck="false" />
    <div id="suggestHome"></div>
  </div>
  <div class="field">
    <input type="text" id="destInput" placeholder="Destination City / Address / Postcode" autocomplete="off" spellcheck="false" />
    <div id="suggestDest"></div>
  </div>
  <div class="field" title="Buffer radius">
    <input type="number" id="radiusInput" min="1" max="100" value="48" />
  </div>
  <div class="field" title="Units">
    <select id="unitsSelect">
      <option value="miles" selected>Miles</option>
      <option value="kilometers">Kilometers</option>
    </select>
  </div>
  <div style="grid-column: 1 / -1; display:flex; gap:8px;">
    <button id="locateBtn" style="flex:0 0 auto; min-width:130px;">üìç Locate Me (Home)</button>
  </div>
</div>

<div id="map"></div>

<div id="legend">
  <h4>Legend</h4>
  <div class="legend-item"><span class="color-box home-boundary"></span>Home City Boundary</div>
  <div class="legend-item"><span class="color-box home-buffer"></span>Traveller‚Äôs Threshold</div>
  <div class="legend-item"><span class="color-box dest-inside"></span>Non Traveller</div>
  <div class="legend-item"><span class="color-box dest-outside"></span>Traveller</div>
  <div class="point-note">If a selected item lacks a polygon, a point+buffer is used.</div>
</div>

<!-- Leaflet -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<!-- Turf.js -->
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
<!-- Overpass JSON -> GeoJSON -->
<script src="https://unpkg.com/osmtogeojson@2.1.0/osmtogeojson.js"></script>

<script>
  // === Hamburger Menu ===
  const menuBtn = document.getElementById('menuBtn');
  const menuDropdown = document.getElementById('menuDropdown');
  function closeMenu(){ menuDropdown.classList.remove('open'); menuBtn.setAttribute('aria-expanded','false'); }
  function openMenu(){ menuDropdown.classList.add('open'); menuBtn.setAttribute('aria-expanded','true'); }
  function toggleMenu(){ menuDropdown.classList.contains('open') ? closeMenu() : openMenu(); }
  menuBtn.addEventListener('click', (e)=>{ e.stopPropagation(); toggleMenu(); });
  document.addEventListener('click', (e)=>{ if (!document.getElementById('menuWrap').contains(e.target)) closeMenu(); });
  document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeMenu(); });
  menuDropdown.addEventListener('keydown', (e)=>{
    const items = Array.from(menuDropdown.querySelectorAll('a.menu-item'));
    const i = items.indexOf(document.activeElement);
    if (e.key === 'ArrowDown'){ e.preventDefault(); (items[(i+1)%items.length]||items[0]).focus(); }
    if (e.key === 'ArrowUp'){ e.preventDefault(); (items[(i-1+items.length)%items.length]||items.at(-1)).focus(); }
  });

  // ===== Map Setup =====
  const map = L.map('map', { zoomControl: false }).setView([53.795, -1.759], 10);
  L.control.zoom({ position: 'bottomleft' }).addTo(map);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19, attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  // ===== Layers =====
  const homeBoundaryLayer = L.geoJSON(null, { style: { color: '#000', weight: 3, fillOpacity: 0.15 } }).addTo(map);
  const homeBufferLayer   = L.geoJSON(null, { style: { color: '#1e90ff', weight: 3, fillOpacity: 0.10 } }).addTo(map);
  const homeMarkerLayer   = L.layerGroup().addTo(map);

  const destOutsideLayer  = L.geoJSON(null, { style: { color: '#2ecc71', weight: 3, fillOpacity: 0.15 } }).addTo(map);
  const destInsideLayer   = L.geoJSON(null, { style: { color: '#e74c3c', weight: 3, fillOpacity: 0.15 } }).addTo(map);
  const destMarkerLayer   = L.layerGroup().addTo(map);

  // ===== State =====
  let homeGeometry = null;   // Feature (Polygon/MultiPolygon) OR Point
  let homeBuffer   = null;   // Feature (Polygon/MultiPolygon)
  let destGeometry = null;   // Feature (Polygon/MultiPolygon) OR Point
  let destPinLatLng = null;  // [lat, lon] when destination is address/postcode centre

  // Destination pin colors (darker shades of existing colors)
  const PIN_GREEN = '#27ae60';
  const PIN_RED   = '#c0392b';

  const homeInput = document.getElementById('homeInput');
  const destInput = document.getElementById('destInput');
  const suggestHome = document.getElementById('suggestHome');
  const suggestDest = document.getElementById('suggestDest');
  const radiusInput = document.getElementById('radiusInput');
  const unitsSelect = document.getElementById('unitsSelect');
  const locateBtn   = document.getElementById('locateBtn');

  let debounceH = null, debounceD = null;

  // ===== Nominatim Search / Reverse =====
  async function searchNominatim(q) {
    const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(q)}&addressdetails=1&limit=7&accept-language=en`;
    const resp = await fetch(url, { headers: { 'User-Agent': 'city-boundary-demo' } });
    if (!resp.ok) throw new Error('Search failed');
    return resp.json();
  }

  async function reverseNominatim(lat, lon) {
    const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}&zoom=10&addressdetails=1&accept-language=en`;
    const resp = await fetch(url, { headers: { 'User-Agent': 'city-boundary-demo' } });
    if (!resp.ok) throw new Error('Reverse failed');
    return resp.json();
  }

  // ===== Overpass helpers =====
  async function fetchBoundaryByRelationId(osmId) {
    const query = `
[out:json][timeout:25];
relation(${osmId});
out body;
>;
out skel qt;`;
    const url = 'https://overpass-api.de/api/interpreter';
    const resp = await fetch(url, { method: 'POST', body: new URLSearchParams({ data: query }) });
    if (!resp.ok) throw new Error('Overpass API error');
    const data = await resp.json();
    return osmtogeojson(data);
  }

  async function fetchBoundaryByName(name) {
    const query = `
[out:json][timeout:25];
relation["boundary"="administrative"]["name"="${name}"];
out body;
>;
out skel qt;`;
    const url = 'https://overpass-api.de/api/interpreter';
    const resp = await fetch(url, { method: 'POST', body: new URLSearchParams({ data: query }) });
    if (!resp.ok) throw new Error('Overpass API error');
    const data = await resp.json();
    return osmtogeojson(data);
  }

  // ===== Helpers =====
  function clearHomeLayers() {
    homeBoundaryLayer.clearLayers();
    homeBufferLayer.clearLayers();
    homeMarkerLayer.clearLayers();
  }
  function clearDestLayers() {
    destOutsideLayer.clearLayers();
    destInsideLayer.clearLayers();
    destMarkerLayer.clearLayers();
  }

  function currentRadiusUnits() {
    const radius = parseFloat(radiusInput.value);
    const units  = unitsSelect.value;
    if (isNaN(radius) || radius <= 0) throw new Error('Radius must be > 0');
    return { radius, units };
  }

  function collectBounds() {
    const groups = [];
    if (homeBoundaryLayer.getLayers().length) groups.push(homeBoundaryLayer);
    if (homeBufferLayer.getLayers().length)   groups.push(homeBufferLayer);
    if (destOutsideLayer.getLayers().length)  groups.push(destOutsideLayer);
    if (destInsideLayer.getLayers().length)   groups.push(destInsideLayer);
    if (homeMarkerLayer.getLayers().length)   groups.push(homeMarkerLayer);
    if (destMarkerLayer.getLayers().length)   groups.push(destMarkerLayer);
    if (!groups.length) return null;
    const fg = L.featureGroup(groups.flatMap(g => g.getLayers ? g.getLayers() : [g]));
    return fg.getBounds();
  }

  function fitToData() {
    const b = collectBounds();
    if (b && b.isValid()) map.fitBounds(b.pad(0.2));
  }

  function extractCityName(addr) {
    if (!addr) return null;
    return addr.city || addr.town || addr.village || addr.municipality || addr.county || addr.state || null;
  }

  // Classify destination specificity
  function classifySpecificity(place) {
    const t = (place.type || '').toLowerCase();
    const cls = (place.class || '').toLowerCase();
    const addt = (place.addresstype || '').toLowerCase();
    if (t === 'postcode' || addt === 'postcode') return 'postcode';
    const addressTypes = ['house','building','residential','yes','address','road','street','highway'];
    if (addressTypes.includes(t) || cls === 'building' || cls === 'highway') return 'address';
    return null;
  }

  // Resolve selected place to polygon or point
  async function resolveGeometryFromPlace(place) {
    if (place.osm_type === 'relation') {
      try {
        const gj = await fetchBoundaryByRelationId(place.osm_id);
        const polys = gj.features.filter(f => f.geometry && (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'));
        if (polys.length) return polys[0];
      } catch (e) { console.warn('Relation fetch failed:', e); }
    }
    const cityName = extractCityName(place.address);
    if (cityName) {
      try {
        const gjByName = await fetchBoundaryByName(cityName);
        const polys = gjByName.features.filter(f => f.geometry && (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'));
        if (polys.length) return polys[0];
      } catch (e) { console.warn('Name-based boundary fetch failed:', e); }
    }
    const lon = parseFloat(place.lon), lat = parseFloat(place.lat);
    return turf.point([lon, lat]);
  }

  function isPolygonal(feature) {
    return feature && feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon');
  }

  // Build a teardrop pin icon with black outline
  function createPinIcon(color) {
    const svg = `
      <svg xmlns="http://www.w3.org/2000/svg" width="26" height="38" viewBox="0 0 26 38">
        <path d="M13 1C6.1 1 1 6.3 1 13.2c0 8.4 9.1 18.1 12 24.9 2.9-6.8 12-16.5 12-24.9C25 6.3 19.9 1 13 1z" fill="${color}" stroke="#000" stroke-width="2"/>
        <circle cx="13" cy="13" r="4.2" fill="#fff" stroke="#000" stroke-width="2"/>
      </svg>`;
    return L.divIcon({ html: svg, className: 'pin-icon', iconSize: [26, 38], iconAnchor: [13, 36] });
  }

  function addDestinationPin() {
    if (!destPinLatLng) return;
    if (homeBuffer) {
      const pt = turf.point([destPinLatLng[1], destPinLatLng[0]]); // lon,lat
      const inside = turf.booleanPointInPolygon(pt, homeBuffer);
      const color = inside ? PIN_RED : PIN_GREEN;
      destMarkerLayer.addLayer(L.marker(destPinLatLng, { icon: createPinIcon(color) }));
    } else {
      destMarkerLayer.addLayer(L.marker(destPinLatLng, { icon: createPinIcon('#333') }));
    }
  }
  function addDestinationPinAt(lat, lon) { destPinLatLng = [lat, lon]; addDestinationPin(); }

  function drawHome(geom) {
    clearHomeLayers();
    homeGeometry = geom;

    const { radius, units } = currentRadiusUnits();

    if (isPolygonal(geom)) {
      homeBoundaryLayer.addData(geom);
      try {
        homeBuffer = turf.buffer(geom, radius, { units });
        homeBufferLayer.addData(homeBuffer);
      } catch (e) { alert('Buffer error (home): ' + e.message); homeBuffer = null; }
    } else {
      const [lon, lat] = geom.geometry.coordinates;
      homeMarkerLayer.addLayer(L.marker([lat, lon]));
      try {
        homeBuffer = turf.buffer(geom, radius, { units });
        homeBufferLayer.addData(homeBuffer);
      } catch (e) { alert('Buffer error (home point): ' + e.message); homeBuffer = null; }
    }
    updateDestinationOverlap();
    fitToData();
  }

  function drawDestination(geom) {
    clearDestLayers();
    destGeometry = geom;

    if (!homeBuffer) {
      if (isPolygonal(geom)) {
        destOutsideLayer.addData(geom);
        if (destPinLatLng) { addDestinationPin(); }
      } else {
        const { radius, units } = currentRadiusUnits();
        const [lon, lat] = geom.geometry.coordinates;
        try {
          const destBuf = turf.buffer(geom, radius, { units });
          destOutsideLayer.addData(destBuf);
        } catch (e) { alert('Buffer error (destination point): ' + e.message); }
        // neutral pin until home buffer exists
        addDestinationPinAt(lat, lon);
      }
      fitToData();
      return;
    }

    updateDestinationOverlap();
    fitToData();
  }

  function updateDestinationOverlap() {
    destOutsideLayer.clearLayers();
    destInsideLayer.clearLayers();
    destMarkerLayer.clearLayers();

    if (!destGeometry) return;

    if (!homeBuffer) {
      if (isPolygonal(destGeometry)) {
        destOutsideLayer.addData(destGeometry);
      } else {
        const { radius, units } = currentRadiusUnits();
        const [lon, lat] = destGeometry.geometry.coordinates;
        try {
          const destBuf = turf.buffer(destGeometry, radius, { units });
          destOutsideLayer.addData(destBuf);
        } catch (e) { alert('Buffer error (destination point): ' + e.message); }
        addDestinationPinAt(lat, lon);
      }
      return;
    }

    if (isPolygonal(destGeometry)) {
      if (destPinLatLng) { addDestinationPin(); }
      try {
        const inside = turf.intersect(destGeometry, homeBuffer);
        if (inside) destInsideLayer.addData(inside);
      } catch (e) { console.warn('Intersect error:', e); }
      try {
        const outside = turf.difference(destGeometry, homeBuffer);
        if (outside) destOutsideLayer.addData(outside);
        if (!outside && destInsideLayer.getLayers().length === 0) {
          destOutsideLayer.addData(destGeometry);
        }
      } catch (e) {
        console.warn('Difference error:', e);
        if (destInsideLayer.getLayers().length === 0) destOutsideLayer.addData(destGeometry);
      }
    } else {
      const { radius, units } = currentRadiusUnits();
      try {
        const destBuf = turf.buffer(destGeometry, radius, { units });
        let hadInside = false;
        try {
          const inside = turf.intersect(destBuf, homeBuffer);
          if (inside) { destInsideLayer.addData(inside); hadInside = true; }
        } catch (e) { console.warn('Point buffer intersect error:', e); }
        try {
          const outside = turf.difference(destBuf, homeBuffer);
          if (outside) destOutsideLayer.addData(outside);
          if (!outside && !hadInside) destOutsideLayer.addData(destBuf);
        } catch (e) { console.warn('Point buffer difference error:', e); if (!hadInside) destOutsideLayer.addData(destBuf); }
        if (destPinLatLng) { addDestinationPin(); }
        else { const [lon, lat] = destGeometry.geometry.coordinates; addDestinationPinAt(lat, lon); }
      } catch (e) { alert('Buffer error (destination point): ' + e.message); }
    }
  }

  // ===== Suggestions UI =====
  function renderSuggestions(container, places, onPick) {
    container.innerHTML = '';
    if (!places || !places.length) { container.style.display = 'none'; return; }
    places.forEach(p => {
      const div = document.createElement('div');
      div.className = 'suggestion';
      div.textContent = p.display_name;
      div.addEventListener('click', async () => {
        container.style.display = 'none';
        try {
          if (container === suggestDest) {
            const spec = classifySpecificity(p);
            if (spec) { destPinLatLng = [parseFloat(p.lat), parseFloat(p.lon)]; }
            else { destPinLatLng = null; }
          }
          const geom = await resolveGeometryFromPlace(p);
          onPick(geom);
        } catch (e) { alert('Failed to resolve selection: ' + e.message); console.error(e); }
      });
      container.appendChild(div);
    });
    container.style.display = 'block';
  }

  // ===== Search Handlers =====
  homeInput.addEventListener('input', () => {
    const q = homeInput.value.trim();
    if (debounceH) clearTimeout(debounceH);
    if (q.length < 3) { suggestHome.style.display = 'none'; return; }
    debounceH = setTimeout(async () => {
      try { const res = await searchNominatim(q); renderSuggestions(suggestHome, res, drawHome); }
      catch (e) { console.error(e); suggestHome.style.display = 'none'; }
    }, 300);
  });

  destInput.addEventListener('input', () => {
    const q = destInput.value.trim();
    if (debounceD) clearTimeout(debounceD);
    if (q.length < 3) { suggestDest.style.display = 'none'; return; }
    debounceD = setTimeout(async () => {
      try { const res = await searchNominatim(q); renderSuggestions(suggestDest, res, drawDestination); }
      catch (e) { console.error(e); suggestDest.style.display = 'none'; }
    }, 300);
  });

  // Hide suggestions when clicking outside
  document.addEventListener('click', (e) => {
    if (!document.getElementById('searchBar').contains(e.target)) {
      suggestHome.style.display = 'none';
      suggestDest.style.display = 'none';
    }
  });

  // ===== Locate Me (sets Home) =====
  locateBtn.addEventListener('click', async () => {
    if (!navigator.geolocation) { alert('Geolocation not supported'); return; }
    locateBtn.disabled = true; locateBtn.textContent = 'Locating‚Ä¶';
    navigator.geolocation.getCurrentPosition(async (pos) => {
      try {
        const lat = pos.coords.latitude, lon = pos.coords.longitude;
        const rev = await reverseNominatim(lat, lon);
        const placeLike = { lat: rev.lat || String(lat), lon: rev.lon || String(lon), osm_type: (rev.osm_type || '').toLowerCase(), osm_id: rev.osm_id, address: rev.address || {} };
        const geom = await resolveGeometryFromPlace(placeLike);
        drawHome(geom);
        homeInput.value = extractCityName(rev.address) || (rev.display_name || `${lat.toFixed(5)}, ${lon.toFixed(5)}`);
      } catch (e) { alert('Locate failed: ' + e.message); console.error(e); }
      finally { locateBtn.disabled = false; locateBtn.textContent = 'üìç Locate Me (Home)'; }
    }, (err) => { alert('Geolocation error: ' + err.message); locateBtn.disabled = false; locateBtn.textContent = 'üìç Locate Me (Home)'; });
  });

  // ===== Radius / Units change =====
  function recomputeAll() { if (homeGeometry) { drawHome(homeGeometry); } if (destGeometry) { drawDestination(destGeometry); } }
  radiusInput.addEventListener('change', () => { try { recomputeAll(); } catch(e){ alert(e.message); } });
  unitsSelect.addEventListener('change',  () => { try { recomputeAll(); } catch(e){ alert(e.message); } });
</script>
</body>
</html>
